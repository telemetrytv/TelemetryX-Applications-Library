import { z as S } from "./index-B98VDFRY.js";
const M = "1.0.0-alpha13", q = {
  version: M
};
class B {
  constructor(e) {
    this._client = e;
  }
  /**
   * Retrieves information about the account associated with the current session.
   *
   * This method allows an application to get details about the TelemetryX account
   * in which it is currently running.
   *
   * @returns A promise that resolves to the current account object
   */
  async getCurrent() {
    return (await this._client.request("user.getCurrentAccount", {})).account;
  }
}
class P {
  constructor(e) {
    this._client = e;
  }
  /**
   * Retrieves all applications with a specific mount point within the current account.
   *
   * This method allows applications that host other applications to discover compatible
   * applications that can be embedded. For example, a dashboard application might search
   * for all applications that have a 'dashboard-widget' mount point.
   *
   * The results are scoped to the current account, so only applications associated with
   * the same account will be returned.
   *
   * @param mountPoint The mount point identifier to search for
   * @returns A promise that resolves to an array of applications having the specified mount point
   */
  async getAllByMountPoint(e) {
    return (await this._client.request("applications.getByMountPoint", {
      mountPoint: e
    })).applications;
  }
  /**
   * Retrieves an application by its name.
   *
   * This method allows finding a specific application when you know its name. It's useful
   * when you need to check if a particular application is available or get its details
   * before attempting to embed it.
   *
   * @param name The name of the application to query for
   * @returns A promise that resolves to the application object if found, or null if not found
   */
  async getByName(e) {
    return (await this._client.request("applications.getByName", {
      name: e
    })).application;
  }
  /**
   * Generates a URL for embedding an application with the specified name and mount point.
   *
   * This method returns a URL that can be used in an iframe src attribute to embed
   * the application. The URL includes necessary parameters for the application to
   * understand its context and communicate with the platform.
   *
   * Only applications that are associated with the current account can be retrieved.
   *
   * @param name The name of the application to get the URL for
   * @param mountPoint The mount point to use when embedding the application
   * @returns A promise that resolves to the URL string for embedding the application
   */
  async getUrl(e, t) {
    return (await this._client.request("applications.getUrl", {
      name: e,
      mountPoint: t
    })).url;
  }
}
function C(r, e = console.error) {
  r().catch(e);
}
class R {
  constructor(e) {
    this._client = e;
  }
  async getColorScheme() {
    return (await this._client.request("environment.getColorScheme", {})).colorScheme;
  }
  subscribeColorScheme(e) {
    C(async () => {
      this._client.on("environment.colorSchemeChanged", e), e(await this.getColorScheme());
    });
  }
  unsubscribeColorScheme(e) {
    this._client.off("environment.colorSchemeChanged", e);
  }
}
class I {
  constructor(e) {
    this._client = e;
  }
  /**
   * Queries for media folders based on folder properties.
   *
   * This method allows you to search for media folders that match specific criteria,
   * such as name, ID, or other folder properties.
   *
   * @param query An object with partial MediaFolder properties to match against
   * @returns A promise that resolves to an array of matching media folders
   */
  async queryFolders(e) {
    return (await this._client.request("media.queryMediaFolders", {
      query: e
    })).folders;
  }
  /**
   * Retrieves media folders that have been tagged with a specific tag.
   *
   * @param tagName The name of the tag to search for
   * @returns A promise that resolves to an array of media folders with the specified tag
   */
  async getFoldersByTag(e) {
    return (await this._client.request("media.getMediaFoldersByTag", {
      tagName: e
    })).folders;
  }
  /**
   * Retrieves a specific media folder by its ID.
   *
   * @param id The unique identifier of the folder to retrieve
   * @returns A promise that resolves to the media folder with the specified ID
   */
  async getFolderById(e) {
    return (await this._client.request("media.getMediaFolderById", {
      id: e
    })).folder;
  }
  /**
   * Retrieves all media content items within a specific folder.
   *
   * @param folderId The unique identifier of the folder to get content from
   * @returns A promise that resolves to an array of media content items in the folder
   */
  async getMediaContentByFolderId(e) {
    return (await this._client.request("media.getMediaContentByFolderId", {
      folderId: e
    })).folders;
  }
  /**
   * Retrieves a specific media content item by its ID.
   *
   * @param id The unique identifier of the media content to retrieve
   * @returns A promise that resolves to the media content item with the specified ID
   */
  async getMediaContentById(e) {
    return (await this._client.request("media.getMediaContentById", {
      id: e
    })).content;
  }
}
class k {
  constructor(e) {
    this._client = e;
  }
  /**
   * Provides access to the application store scope.
   *
   * Data stored in the application scope is shared across all instances of your application
   * within the current account. Use this scope for application-wide settings, shared resources,
   * or any data that should be consistent across all instances.
   *
   * @returns A StoreSlice instance for the application scope
   */
  get application() {
    return new w("application", "", this._client);
  }
  /**
   * Provides access to the instance store scope.
   *
   * Data stored in the instance scope is only available to the current instance of your
   * application. This is ideal for instance-specific settings, UI state, temporary data,
   * or any information that shouldn't be shared with other instances.
   *
   * The namespace for instance data includes both the application name and the instance ID.
   *
   * @returns A StoreSlice instance for the instance scope
   */
  get instance() {
    return new w("instance", this._client._applicationId, this._client);
  }
  /**
   * Provides access to the device store scope.
   *
   * Data stored in the device scope is only available to the application on the
   * current physical device. This is useful for device-specific settings, caching, or
   * any data that should persist across application instances but only on a single device.
   *
   * Note: This scope cannot be used for Settings-related mount points as the User
   * Administration UI does not run on a device.
   *
   * @returns A StoreSlice instance for the device scope
   */
  get device() {
    return new w("device", this._client._applicationId, this._client);
  }
  /**
   * Provides access to the shared store scope with a specified namespace.
   *
   * The shared scope enables data sharing between different applications within the
   * same account. By specifying a common namespace, any two applications can exchange
   * data and communicate with each other.
   *
   * This is particularly useful for application ecosystems where multiple applications
   * need to coordinate or share configuration.
   *
   * @param namespace A string identifier for the shared data space
   * @returns A StoreSlice instance for the specified shared namespace
   */
  shared(e) {
    return new w("shared", e, this._client);
  }
}
class w {
  constructor(e, t, s) {
    this._kind = e, this._namespace = t, this._client = s;
  }
  /**
   * Saves a value in the store.
   *
   * This method stores data under the specified key within the current store scope and namespace.
   * The value must be serializable (can be converted to JSON). Complex objects like Date instances
   * will be serialized and deserialize as regular objects, losing their prototype methods.
   *
   * @param key The key to save the value under
   * @param value The value to store - must be JSON serializable
   * @returns A promise that resolves to true if the value was saved successfully
   */
  async set(e, t) {
    return (await this._client.request("store.set", {
      kind: this._kind,
      namespace: this._namespace,
      key: e,
      value: t
    })).success;
  }
  /**
   * Retrieves a value from the store.
   *
   * This method fetches data stored under the specified key within the current store scope
   * and namespace. For real-time applications that need to respond to changes, consider
   * using subscribe() instead.
   *
   * @template T The expected type of the stored value
   * @param key The key to retrieve the value for
   * @returns A promise that resolves to the stored value, or undefined if the key does not exist
   */
  async get(e) {
    return (await this._client.request("store.get", {
      kind: this._kind,
      namespace: this._namespace,
      key: e
    })).value;
  }
  /**
   * Subscribes to changes in the store for a specific key.
   *
   * This method sets up a subscription that will call the provided handler whenever
   * the value associated with the specified key changes. This is the recommended way
   * to access store data in long-running applications that need to stay responsive
   * to data changes.
   *
   * @param key The key to subscribe to
   * @param handler The callback function to call when the value changes
   * @returns A promise that resolves to true if the subscription was successful
   */
  async subscribe(e, t) {
    return (await this._client.subscribe("store.subscribe", {
      kind: this._kind,
      namespace: this._namespace,
      key: e
    }, t)).success;
  }
  /**
   * Unsubscribes from changes in the store for a specific key.
   *
   * This method removes a subscription previously created with subscribe(). It can
   * either remove a specific handler or all handlers for the given key.
   *
   * @param key The key to unsubscribe from
   * @param handler Optional. The specific handler to remove. If not provided, all handlers for this key will be removed.
   * @returns A promise that resolves to true if the unsubscription was successful
   */
  async unsubscribe(e, t) {
    return (await this._client.unsubscribe("store.unsubscribe", {
      kind: this._kind,
      namespace: this._namespace,
      key: e
    }, t)).success;
  }
  /**
   * Deletes a value from the store.
   *
   * This method removes the data stored under the specified key within the
   * current store scope and namespace.
   *
   * @param key The key to delete
   * @returns A promise that resolves to true if the value was deleted successfully
   */
  async delete(e) {
    return (await this._client.request("store.delete", {
      kind: this._kind,
      namespace: this._namespace,
      key: e
    })).success;
  }
}
class E {
  constructor(e) {
    this._client = e;
  }
  /**
   * Retrieves information about the user associated with the current session.
   *
   * This method allows an application to get details about the TelemetryX user
   * who is currently using the application.
   *
   * @returns A promise that resolves to the current user result object
   * @example
   * // Get the current user information
   * const userResult = await users.getCurrent();
   * console.log(`Current user ID: ${userResult.user.id}`);
   */
  async getCurrent() {
    return await this._client.request("user.getCurrentUser", {});
  }
}
const $ = S.object({
  name: S.string(),
  data: S.any().optional()
});
class A {
  /**
   * Creates a new RootSettingsNavigation API instance.
   *
   * @param store The Store instance to use for persistence
   * @throws {Error} If used by an application not mounted at the 'rootSettingsNavigation' mount point
   */
  constructor(e) {
    if (e._client._applicationId !== "rootSettingsNavigation")
      throw new Error("RootSettingsNavigation can only be used in the rootSettingsNavigation mount point");
    this._store = e;
  }
  /**
   * Registers navigation entries for the root application in the TelemetryX admin UI.
   *
   * This method allows a root application to define its sidebar navigation structure
   * within the TelemetryX administration UI. The navigation entries will appear in the
   * sidebar menu, allowing users to navigate to different sections of the application.
   *
   * @param navigation An object containing the navigation entries to register
   * @returns A promise that resolves when the navigation has been registered
   */
  async setRootSettingsNavigation(e) {
    const t = this._store.shared("root-settings-navigation"), s = await t.get("navigation"), o = this._store._client._applicationId;
    s[o] = {
      applicationId: o,
      entries: e.entries
    }, t.set("navigation", s);
  }
  /**
   * Retrieves the current navigation entries for this root application.
   *
   * This method returns the navigation structure that was previously registered
   * for this application using setRootSettingsNavigation().
   *
   * @returns A promise that resolves to the navigation state for this application
   */
  async getRootSettingsNavigation() {
    const t = await this._store.shared("root-settings-navigation").get("navigation"), s = this._store._client._applicationId;
    return t[s];
  }
  /**
   * Retrieves the navigation entries for all root applications.
   *
   * This method returns the navigation structures for all root applications registered
   * in the TelemetryX administration UI. This can be useful for coordination between
   * different root applications.
   *
   * @returns A promise that resolves to the navigation state for all applications
   */
  async getAllRootSettingsNavigation() {
    return this._store.shared("root-settings-navigation").get("navigation");
  }
}
const m = 1e3 * 30;
class T {
  /**
   * Creates a new Client instance for communicating with the TelemetryX platform.
   *
   * Note that creating a Client instance alone is not sufficient to begin communication.
   * You must also call the bind() method to initialize event listeners and extract
   * the application ID from the URL.
   *
   * @param applicationName The name of your application - must match the 'name' property
   *                        in your application's telemetry.config.json file
   */
  constructor(e) {
    this._applicationName = e, this._applicationId = "", this._onHandlers = /* @__PURE__ */ new Map(), this._onceHandlers = /* @__PURE__ */ new Map(), this._subscriptionNamesByHandler = /* @__PURE__ */ new Map(), this._subscriptionNamesBySubjectName = /* @__PURE__ */ new Map();
  }
  /**
   * Provides access to the accounts API for retrieving TelemetryX account information.
   *
   * This property returns a new Accounts instance that allows querying information
   * about the current TelemetryX account.
   *
   * NOTE: Most application developers should use the global accounts() function
   * instead of accessing this property directly.
   *
   * @returns An Accounts instance bound to this client
   */
  get accounts() {
    return new B(this);
  }
  /**
   * Provides access to the users API for retrieving TelemetryX user information.
   *
   * This property returns a new Users instance that allows querying information
   * about the current TelemetryX user.
   *
   * NOTE: Most application developers should use the global users() function
   * instead of accessing this property directly.
   *
   * @returns A Users instance bound to this client
   */
  get users() {
    return new E(this);
  }
  /**
   * Provides access to the store API for data persistence with multiple storage scopes.
   *
   * This property returns a new Store instance that allows saving, retrieving, and
   * subscribing to data changes across different scopes (global, local, deviceLocal, shared).
   *
   * NOTE: Most application developers should use the global store() function
   * instead of accessing this property directly.
   *
   * @returns A Store instance bound to this client
   */
  get store() {
    return new k(this);
  }
  /**
   * Provides access to the applications API for discovering and embedding other TelemetryX applications.
   *
   * This property returns a new Applications instance that allows querying for applications
   * by name or mount point, and generating URLs for embedding applications in iframes.
   *
   * NOTE: Most application developers should use the global applications() function
   * instead of accessing this property directly.
   *
   * @returns An Applications instance bound to this client
   */
  get applications() {
    return new P(this);
  }
  /**
   * Provides access to the media API for working with content hosted on the TelemetryX platform.
   *
   * This property returns a new Media instance that allows applications to browse and access
   * media content uploaded to TelemetryX. Applications can query folders, retrieve content,
   * and access media files.
   *
   * NOTE: Most application developers should use the global media() function
   * instead of accessing this property directly.
   *
   * @returns A Media instance bound to this client
   */
  get media() {
    return new I(this);
  }
  /**
   * Provides access to the root settings navigation API for TelemetryX administration UI integration.
   *
   * NOTE: This API is not intended for most application developers. It is specifically designed
   * for root applications that need to integrate with the TelemetryX administration UI.
   *
   * This property returns a new RootSettingsNavigation instance that allows root applications
   * to register sidebar navigation entries in the TelemetryX administration UI.
   *
   * Most root application developers should use the global rootSettingsNavigation() function
   * instead of accessing this property directly.
   *
   * @returns A RootSettingsNavigation instance bound to this client
   * @throws {Error} If used by an application not mounted at the 'rootSettingsNavigation' mount point
   */
  get rootSettingsNavigation() {
    return new A(this.store);
  }
  /**
   * Initializes the client by setting up message listeners and extracting the application ID.
   *
   * This method must be called after creating a Client instance and before using any
   * of its communication methods. It performs two important tasks:
   *
   * 1. Sets up an event listener for window 'message' events to receive messages
   *    from the TelemetryX platform
   * 2. Extracts the application ID from the URL's query parameters
   *
   * The application ID is used by several APIs, including the store's local and deviceLocal scopes.
   *
   * NOTE: Most application developers should use the global configure() function instead
   * of creating and binding their own Client instances.
   */
  bind() {
    var e;
    const t = new URL(window.location.href).searchParams;
    this._applicationId = (e = t.get("telemetryApplicationId")) !== null && e !== void 0 ? e : "", this._windowMessageHandler = (s) => {
      if (s.source === window)
        return;
      for (let a = 0; a < window.frames.length; a += 1)
        window.frames[a].postMessage(s.data, "*");
      const o = $.safeParse(s.data);
      if (!o.success)
        return;
      const i = o.data, c = this._onHandlers.get(i.name), l = this._onceHandlers.get(i.name);
      if (c)
        for (const a of c)
          a(i.data);
      if (l) {
        for (const a of l)
          a(i.data);
        this._onceHandlers.delete(i.name);
      }
    }, window.addEventListener("message", this._windowMessageHandler);
  }
  /**
   * Removes the message event listener and cleans up resources.
   *
   * Call this method when you're done with the client to prevent memory leaks
   * and ensure proper cleanup. After calling unbind(), the client will no longer
   * receive messages from the TelemetryX platform.
   *
   * Note that this does not cancel any active subscriptions or server-side resources.
   * You should explicitly unsubscribe from any subscriptions before unbinding.
   *
   * NOTE: Most application developers should use the global destroy() function instead
   * of managing their own Client instances.
   */
  unbind() {
    this._windowMessageHandler && window.removeEventListener("message", this._windowMessageHandler);
  }
  /**
   * Sends a one-way message to the TelemetryX platform.
   *
   * Use this method for fire-and-forget messages where no response is expected.
   * The message is sent to the parent window using the postMessage API and includes
   * metadata such as the SDK version and application name.
   *
   * NOTE: Most application developers should use the resource-specific APIs or the global
   * send() function instead of using this method directly.
   *
   * @param name The name of the message type to send
   * @param data The data payload to include with the message
   */
  send(e, t) {
    const s = {
      telemetrySdkVersion: y,
      applicationName: this._applicationName,
      name: e,
      data: t
    };
    window.parent.postMessage(s, "*");
  }
  /**
   * Sends a message to the TelemetryX platform and waits for a response.
   *
   * This method implements a request-response pattern over the postMessage API.
   * It generates a unique correlation ID and sets up a listener for the response.
   * If no response is received within the timeout period (30 seconds by default),
   * the promise will reject.
   *
   * NOTE: Most application developers should use the resource-specific APIs or the global
   * request() function instead of using this method directly.
   *
   * @template D The expected type of the response data
   * @param name The name of the message type (endpoint) to request
   * @param data The data payload to include with the request
   * @returns A promise that resolves with the response data when received
   * @throws {Error} If the request times out
   */
  request(e, t) {
    const s = b(), o = {
      telemetrySdkVersion: y,
      applicationName: this._applicationName,
      name: e,
      data: t,
      responseName: s
    };
    window.parent.postMessage(o, "*");
    let i = !1, c;
    const l = new Promise((h, d) => {
      const p = new Error(`${e} message request with response name of ${s} timed out after ${m}`);
      setTimeout(() => {
        i = !0, this.off(s, c), d(p);
      }, m);
    }), a = new Promise((h) => {
      c = (d) => {
        i || h(d);
      }, this.once(s, h);
    });
    return Promise.race([l, a]);
  }
  async subscribe(e, t, s) {
    let o, i;
    typeof t == "function" ? i = t : (o = t, i = s);
    const c = b(), l = b();
    let a = this._subscriptionNamesBySubjectName.get(e);
    a || (a = [], this._subscriptionNamesBySubjectName.set(e, a)), a.push(c), this._subscriptionNamesByHandler.set(i, c), this.on(c, i);
    const h = {
      telemetrySdkVersion: y,
      applicationName: this._applicationName,
      name: e,
      data: o,
      responseName: l,
      subscriptionName: c
    };
    window.parent.postMessage(h, "*");
    let d = !1, p;
    const N = new Promise((_, g) => {
      const f = new Error(`${e} subscribe request with subscription name of ${c} and response name of ${l} timed out after ${m}`);
      setTimeout(() => {
        d = !0, this.off(l, p), g(f);
      }, m);
    }), v = new Promise((_) => {
      p = (g) => {
        d || _(g);
      }, this.on(l, _);
    });
    return Promise.race([N, v]);
  }
  async unsubscribe(e, t, s) {
    let o, i;
    typeof t == "function" ? i = t : (o = t, i = s);
    const c = b();
    let l = [];
    if (i) {
      const a = this._subscriptionNamesByHandler.get(i);
      if (!a)
        return { success: !1 };
      l = [a], this._subscriptionNamesByHandler.delete(i);
    } else if (!this._subscriptionNamesBySubjectName.get(e))
      return { success: !1 };
    for await (const a of l) {
      this.off(a, i);
      const h = {
        telemetrySdkVersion: y,
        applicationName: this._applicationName,
        name: e,
        data: o,
        responseName: c,
        unsubscribeName: a
      };
      window.parent.postMessage(h, "*");
      let d = !1, p;
      const N = new Promise((g, f) => {
        const H = new Error(`${e} unsubscribe request with unsubscribe name of ${a} and response name of ${c} timed out after ${m}`);
        setTimeout(() => {
          d = !0, this.off(c, p), f(H);
        }, m);
      }), v = new Promise((g) => {
        p = (f) => {
          d || g(f);
        }, this.once(c, g);
      });
      if (!(await Promise.race([N, v])).success)
        return { success: !1 };
    }
    return { success: !0 };
  }
  /**
   * Registers a handler function for a specific message type.
   *
   * The handler will be called each time a message with the specified name is received.
   * You can register multiple handlers for the same message type, and all will be executed
   * when that message is received.
   *
   * Unlike subscribe(), this method only sets up a local event listener and doesn't
   * notify the platform of your interest in a particular message type.
   *
   * NOTE: Most application developers should use the resource-specific APIs or the global
   * on() function instead of using this method directly.
   *
   * @template T The expected type of the message data
   * @param name The name of the message type to listen for
   * @param handler The callback function to execute when messages are received
   */
  on(e, t) {
    var s;
    const o = (s = this._onHandlers.get(e)) !== null && s !== void 0 ? s : [];
    o.length === 0 && this._onHandlers.set(e, o), o.push(t);
  }
  /**
   * Registers a one-time handler for a specific message type.
   *
   * Similar to the on() method, but the handler will be automatically removed
   * after it is called once. This is useful for initialization events or operations
   * that should only happen once in response to a particular message.
   *
   * NOTE: Most application developers should use the resource-specific APIs or the global
   * once() function instead of using this method directly.
   *
   * @template T The expected type of the message data
   * @param name The name of the message type to listen for
   * @param handler The callback function to execute when the message is received
   */
  once(e, t) {
    var s;
    const o = (s = this._onceHandlers.get(e)) !== null && s !== void 0 ? s : [];
    o.length === 0 && this._onceHandlers.set(e, o), o.push(t);
  }
  /**
   * Removes previously registered message handlers.
   *
   * Use this method to stop receiving messages of a specific type or to remove
   * specific handler functions when they're no longer needed. This applies to
   * handlers registered with both on() and once() methods.
   *
   * NOTE: Most application developers should use the resource-specific APIs or the global
   * off() function instead of using this method directly.
   *
   * @template T The expected type of the message data
   * @param name The name of the message type to stop listening for
   * @param handler Optional. The specific handler function to remove. If omitted,
   *                all handlers for this message type will be removed.
   */
  off(e, t) {
    const s = this._onHandlers.get(e), o = this._onceHandlers.get(e);
    if (!(!s && !o)) {
      if (s) {
        for (let i = 0; i < s.length; i += 1)
          t && s[i] !== t || (s.splice(i, 1), i -= 1);
        s.length === 0 && this._onHandlers.delete(e);
      }
      if (o) {
        for (let i = 0; i < o.length; i += 1)
          t && o[i] !== t || (o.splice(i, 1), i -= 1);
        o.length === 0 && this._onceHandlers.delete(e);
      }
    }
  }
}
function b() {
  return Math.random().toString(36).slice(2, 9);
}
const y = q.version;
let n = null;
function j() {
  return n;
}
function U(r) {
  n = new T(r), n.bind();
}
function L() {
  n == null || n.unbind(), n = null;
}
function V(...r) {
  return u(n), n.on(...r);
}
function x(...r) {
  return u(n), n.once(...r);
}
function z(...r) {
  return u(n), n.off(...r);
}
function D(...r) {
  return u(n), n.send(...r);
}
function K(...r) {
  return u(n), n.request(...r);
}
function G(...r) {
  return u(n), n.subscribe(...r);
}
function J(...r) {
  return u(n), n.unsubscribe(...r);
}
function Q() {
  return u(n), n.store;
}
function W() {
  return u(n), n.applications;
}
function X() {
  return u(n), n.media;
}
function Y() {
  return u(n), n.accounts;
}
function Z() {
  return u(n), n.users;
}
function O() {
  return u(n), n.rootSettingsNavigation;
}
function u(r) {
  if (!r)
    throw new Error("SDK is not configured");
}
export {
  B as Accounts,
  P as Applications,
  T as Client,
  R as Environment,
  I as Media,
  k as Store,
  E as Users,
  Y as accounts,
  W as applications,
  U as configure,
  L as destroy,
  j as globalClient,
  X as media,
  z as off,
  V as on,
  x as once,
  K as request,
  O as rootSettingsNavigation,
  D as send,
  Q as store,
  G as subscribe,
  y as telemetrySdkVersion,
  J as unsubscribe,
  Z as users
};
